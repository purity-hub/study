@[TOC](目录)
# 概述
对于C、C++开发，在内存管理领域拥有每一个对象的所有权，又担负着每一个对象生命开始到终结的维护责任。

**java虚拟机自动内存管理机制，不需要为每一个new操作去配对的delete/free代码**，不容易出现内存泄漏和内存溢出问题，但是一旦出现了内存泄露和溢出问题，如果不了解虚拟机时怎样使用内存的，那么排查将是一项艰难的工作。

# 运行时数据区域
在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。
![在这里插入图片描述](https://img-blog.csdnimg.cn/dd9595dab6bc460bb4b4c4d86a953240.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcHVyaXR5LWdvb2Q=,size_19,color_FFFFFF,t_70,g_se,x_16)
## 程序计数器
较小的内存空间

**当前线程所执行的字节码的行号指示器**

在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。

java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。为了线程切换后能回到原来正确的执行位置，每条线程都需要一个独立的程序计数器、各线程之间计数器互不影响，独立存储，**线程私有**

## java虚拟机栈
也是线程私有，生命周期与线程相同。

jav方法执行的内存模型：每个方法会在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机中入栈到出栈的过程。

## 本地方法栈
本地方法栈为虚拟机使用到的Native方法服务。

## java堆
对于大多数应用，java堆是java虚拟机所管理的内存中最大的一块。

jav堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。
**唯一目的：存放对象的实例。**

所有对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换-优化技术将这些变得不再那么绝对

java堆是垃圾收集器管理的主要区域，因此也被称为GC堆。

java在内存分配上可以划分为多个线程私有的分配缓冲区。但是划分的目的只是为了更好地回收内存。

## 方法区
与java堆一样，是各个线程共享地内存区域，它用于存储已被虚拟机加载地类信息、常量、静态变量、即使编译器编译后地代码等数据。

## 运行时常量池
方法区的一部分

Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面值和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

相对于Class文件常量池具备动态性：并不要求常量一定只有编译器才能产生，也就是并非预置入Class文件中的常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的变量放入池中，比如String类的intern方法。

## 直接内存
本机直接内存的分配不会受到java堆大小的限制，但是还是会受到本机总内存大小以及处理器寻址空间的限制。
# HotSpot虚拟机对象
*如何创建、如何布局、如何访问*

## 对象的创建
new---->首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。


类加载检查后，将为新生对象分配内存。对象所需的内存大小在类加载完成后便可以完全确定，为对象分配空间等同于把一块确定大小的内存从java堆中划分出来。

分配方式：

 - 指针碰撞
 - 空闲列表

对象在虚拟机中创建是十分频繁的，所有可能出现线程不安全，比如a在分配内存后，指针来不及改变，又有一个内存分配在了原先的内存上。

解决上面这种问题的解决方案：

 - 对分配内存空间的动作进行同步处理
 - 把内存分配的动作按照线程划分在不同的空间之中进行

内存分配完成后，虚拟机需要将分配到的内存区域初始化为零值。
保证了对象的实例字段在java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。

执行new指令之后，执行<init方法>，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象完全产生出来。

## 对象的内存布局
对象头、实例数据、对齐填充

![在这里插入图片描述](https://img-blog.csdnimg.cn/f386ebfcbc4a4809948832e57792a15a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcHVyaXR5LWdvb2Q=,size_20,color_FFFFFF,t_70,g_se,x_16)
## 对象的访问定位
java程序需要通过栈上的reference数据来操作堆上的具体对象。
reference类型在java虚拟机规范中只规定了一个对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式取决于虚拟机实现而定的。

目前的主流的访问方式有**使用句柄**和直**接指针**两种。

![在这里插入图片描述](https://img-blog.csdnimg.cn/96fdf06100634ebfb394f1d5f4c1eac1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcHVyaXR5LWdvb2Q=,size_20,color_FFFFFF,t_70,g_se,x_16)
![在这里插入图片描述](https://img-blog.csdnimg.cn/50375e891a794a74b7ef5479dea37035.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcHVyaXR5LWdvb2Q=,size_20,color_FFFFFF,t_70,g_se,x_16)



